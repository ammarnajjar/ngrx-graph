#!/usr/bin/env node

const oclif = require('@oclif/core')

const { spawnSync } = require('child_process');
const path = require('path')
const project = path.join(__dirname, '..', 'tsconfig.json')

// In dev mode -> use ts-node and dev plugins
process.env.NODE_ENV = 'development'

// If the user invoked flag-style args (e.g. `./bin/dev -d ./src --out ./out`),
// used the single-command form (`graph <action>`), or invoked a positional
// action first (e.g. `./bin/dev loadProductions ...`), forward directly to the
// TypeScript/commander CLI so flags are parsed by that implementation instead
// of oclif. This makes the dev wrapper more convenient for local testing.
const rawArgs = process.argv.slice(2) || [];
const looksLikeFlags = rawArgs.length > 0 && rawArgs[0].startsWith('-');
// Treat any positional-first token (that is not a help/version flag) as an
// intent to invoke the TypeScript CLI. We no longer special-case `graph`.
const firstArg = rawArgs.length > 0 ? rawArgs[0] : undefined;
const helpLike = firstArg === 'help' || firstArg === '--help' || firstArg === '-h' || firstArg === 'version' || firstArg === '--version';
const looksLikeSingleCommand = rawArgs.length > 0 && (!firstArg?.startsWith('-') && !helpLike);

if (looksLikeFlags || looksLikeSingleCommand) {
	// Run the TS CLI directly with ts-node preloaded so dev behavior matches
	// the TypeScript CLI. We do not call require('ts-node').register() in this
	// process because we spawn a child that preloads ts-node for isolation.
	const node = process.execPath || 'node';
	// Forward args unchanged; do not strip any positional token.
	let forwardArgs = rawArgs.slice();

	// Canonicalize common path flags so the TypeScript CLI doesn't end up
	// resolving a relative --out against the scan dir (which causes nested
	// incorrect paths). Resolve values relative to the current working dir.
	const resolveIfPath = (val) => path.isAbsolute(val) ? val : path.resolve(process.cwd(), val);
	for (let i = 0; i < forwardArgs.length; i++) {
		const a = forwardArgs[i];
		if (a === '-d' || a === '--dir' || a === '-o' || a === '--out') {
			if (i + 1 < forwardArgs.length) {
				forwardArgs[i + 1] = resolveIfPath(forwardArgs[i + 1]);
				i++; // skip value
			}
		} else if (a.startsWith('--out=') || a.startsWith('--dir=')) {
			const [k, v] = a.split('=');
			forwardArgs[i] = `${k}=${resolveIfPath(v)}`;
		}
	}

	const args = ['-r', 'ts-node/register', path.join(__dirname, '..', 'src', 'cli.ts'), ...forwardArgs];
	// Always spawn the TypeScript CLI with the repository root as cwd so
	// project-local modules and preloads (e.g. ts-node/register) resolve
	// consistently, regardless of where the user invoked the wrapper.
	const childCwd = path.join(__dirname, '..');
	const res = spawnSync(node, args, { stdio: 'inherit', cwd: childCwd });
	process.exit(res.status ?? 0);
}

// Otherwise run oclif as usual (e.g., when running built commands or help)
require('ts-node').register({project})
// In dev mode, always show stack traces
oclif.settings.debug = true;

// Start the CLI
oclif.run().then(oclif.flush).catch(oclif.Errors.handle)
